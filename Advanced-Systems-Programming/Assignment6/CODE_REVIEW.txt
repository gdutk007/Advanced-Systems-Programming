/*                  Case 1 
    The first Critical Section with a race condition is 
    the Write() and Read() with the Character Device Driver set to MODE2.
    
    When multiple threads are writing and reading to the ramdisk buffer we don't 
    see the driver using the file offset. This can cause multiple threads 
    writing to the buffer to overwrite data written by the 
    previous thread. This would mean that when reading from the 
    ramdisk buffer data will be read incorrectly. The specific line is 
    the following: 
        copy_from_user(devc->ramdisk, buf, count);   (Line 127)
        and 
        ret = count - copy_to_user(buf, devc->ramdisk, count); (Line 100)
    
    While the ramdisk buffer is protected by semaphore 1, it is still a race condition 
    since we are not keeping track of the position and we cannot guarantee the data.
    When reading and semaphore 1 is locked before reading/writing and unlocked after 
    reading/writing. 
*/

/*                  Case 2
    Another region of code that has a race condition is the read and write operations 
    during "MODE 1". During "MODE 1" read and write does not protect the ramdisk buffer.
    This means that if someone tried to run several read and write threads in parallel 
    the data in the buffer could be overwritten and misread. This is similar to Case 1 
    but even more incorrect since sempahore 1 is released before reading and writing. 
*/

/*                  Case 3
    The next pair of critical sections that has race conditions is the critical section 
    during open() and during the ioctl() functions when we are switching back to "MODE 1".

    If the driver is in MODE 2 and multiple threads are calling open() the driver will increment the 
    mode 2 counter by 1 each time. This is problematic if any of the threads are trying to switch 
    back to mode  1. ioctl() would be called to switch back to mode 1 and the driver will block 
    until the mode 2 counter is decremented to 1. To avoid deadlocks and for the number to be correct, 
    it would be better if the driver would decrement the count befor waiting. That way if every thread 
    tried to switch to MODE 1, it would update the value immediately. The mode 2 counter would reflect 
    the real number of threads trying to be in mode 1.  

*/

/*                  Case 4
    The last pair of critical sections I will cover are the critical sections of open()
    and the release() functions. These two critical sections do not have race conditions.
    They make sure to aquire the semaphore 1 lock before doing anything to count1 and 
    count2. The prevents buggy behavior reading and writing to these values. After they 
    are done they release their locks and the functions exit.  
*/

